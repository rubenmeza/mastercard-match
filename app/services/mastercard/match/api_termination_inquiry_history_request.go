/*
 * MATCH API
 *
 * Helps acquirers identify potentially high-risk merchants before entering to a merchant agreement.
 *
 * API version: 1.0.0
 * Contact: apisupport@mastercard.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package match

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// TerminationInquiryHistoryRequestApiService TerminationInquiryHistoryRequestApi service
type TerminationInquiryHistoryRequestApiService service

type ApiTerminationInquiryIRNGetRequest struct {
	ctx _context.Context
	ApiService *TerminationInquiryHistoryRequestApiService
	pageOffset *int32
	pageLength *int32
	format *string
	acquirerId *string
	iRN string
}

func (r ApiTerminationInquiryIRNGetRequest) PageOffset(pageOffset int32) ApiTerminationInquiryIRNGetRequest {
	r.pageOffset = &pageOffset
	return r
}
func (r ApiTerminationInquiryIRNGetRequest) PageLength(pageLength int32) ApiTerminationInquiryIRNGetRequest {
	r.pageLength = &pageLength
	return r
}
func (r ApiTerminationInquiryIRNGetRequest) Format(format string) ApiTerminationInquiryIRNGetRequest {
	r.format = &format
	return r
}
func (r ApiTerminationInquiryIRNGetRequest) AcquirerId(acquirerId string) ApiTerminationInquiryIRNGetRequest {
	r.acquirerId = &acquirerId
	return r
}

func (r ApiTerminationInquiryIRNGetRequest) Execute() (TerminationInquirySchema, *_nethttp.Response, error) {
	return r.ApiService.TerminationInquiryIRNGetExecute(r)
}

/*
 * TerminationInquiryIRNGet ##### Retrieves historical termination inquiry results.
 * Returns information about Merchants, URLs and up to five principal owners, that have been terminated by an acquiring bank from a previous inquiry. To access the inquiry results of the past inquiries, acquirer should pass the inquiry reference number (IRN) received from the previous inquiries (TerminationInquiryRequest). For further details refer the documentation on [Use Cases.](/match/documentation/use-cases) 

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param iRN Inquiry Reference Number (IRN) A unique identifier generated by the MATCH system that is returned in the original, previously submitted POST request (contained within the \"TerminationInquiry.Ref\" response node). This unique identifier should be present as a URL parameter within all GET requests.
 * @return ApiTerminationInquiryIRNGetRequest
 */
func (a *TerminationInquiryHistoryRequestApiService) TerminationInquiryIRNGet(ctx _context.Context, iRN string) ApiTerminationInquiryIRNGetRequest {
	return ApiTerminationInquiryIRNGetRequest{
		ApiService: a,
		ctx: ctx,
		iRN: iRN,
	}
}

/*
 * Execute executes the request
 * @return TerminationInquirySchema
 */
func (a *TerminationInquiryHistoryRequestApiService) TerminationInquiryIRNGetExecute(r ApiTerminationInquiryIRNGetRequest) (TerminationInquirySchema, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TerminationInquirySchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TerminationInquiryHistoryRequestApiService.TerminationInquiryIRNGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/termination-inquiry/{IRN}"
	localVarPath = strings.Replace(localVarPath, "{"+"IRN"+"}", _neturl.PathEscape(parameterToString(r.iRN, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.pageOffset == nil {
		return localVarReturnValue, nil, reportError("pageOffset is required and must be specified")
	}
	if r.pageLength == nil {
		return localVarReturnValue, nil, reportError("pageLength is required and must be specified")
	}
	if r.format == nil {
		return localVarReturnValue, nil, reportError("format is required and must be specified")
	}
	if r.acquirerId == nil {
		return localVarReturnValue, nil, reportError("acquirerId is required and must be specified")
	}

	localVarQueryParams.Add("PageOffset", parameterToString(*r.pageOffset, ""))
	localVarQueryParams.Add("PageLength", parameterToString(*r.pageLength, ""))
	localVarQueryParams.Add("Format", parameterToString(*r.format, ""))
	localVarQueryParams.Add("AcquirerId", parameterToString(*r.acquirerId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
